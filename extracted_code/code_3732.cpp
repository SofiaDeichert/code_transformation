int knownP [ 10000 ] = { 0 } ; int rtTrg [ MAXL ] [ MAXL ] ; int maxPath ( int level , int offset , int maxlevel ) { int sum1 , sum2 ; if ( ( knownP [ level * 100 + offset ] != UNKNOWN ) && ( ! NOMOREDOWN ) ) { return knownP [ level * 100 + offset ] ; } if ( NOMOREDOWN ) { return knownP [ level * 100 + offset ] = rtTrg [ level ] [ offset ] ; } else { sum1 = maxPath ( level + 1 , offset , maxlevel ) ; sum2 = maxPath ( level + 1 , offset + 1 , maxlevel ) ; knownP [ level * 100 + offset ] = ( ( sum1 > sum2 ) ? sum1 : sum2 ) + rtTrg [ level ] [ offset ] ; return knownP [ level * 100 + offset ] ; } return ; } void fastread_D ( int * base ) { char c = 0 ; while ( c < 33 ) { c = getchar_unlocked ( ) ; } * base = 0 ; while ( c > 33 ) { * base = * base * 10 + c - '0' ; c = getchar_unlocked ( ) ; } } int main ( ) { int i , j , cases ; int totalLevels = 0 ; fastread_D ( & cases ) ; while ( cases -- ) { memset ( rtTrg , 0 , sizeof ( rtTrg ) ) ; memset ( knownP , UNKNOWN , sizeof ( knownP ) ) ; fastread_D ( & totalLevels ) ; for ( i = 0 ; i < totalLevels ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { fastread_D ( & rtTrg [ i ] [ j ] ) ; } } printf ( "%d\n" , maxPath ( 0 , 0 , totalLevels - 1 ) ) ; } return 0 ; }
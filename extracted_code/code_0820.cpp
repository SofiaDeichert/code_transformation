int a [ 100 ] [ 100 ] ; int recurse ( int a [ 100 ] [ 100 ] , int n , int sum , int i , int j , int sum_prev ) ; int top = - 1 ; int stack [ max ] ; int push ( int item ) ; int is_empty ( ) ; int is_full ( ) ; int main ( ) { int t ; int n ; int i ; int j ; scanf ( "%d" , & t ) ; while ( t -- ) { int sum = 0 ; int sum_prev = 0 ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { scanf ( "%d" , & a [ i ] [ j ] ) ; } } i = 0 ; j = 0 ; recurse ( a , n , sum , i , j , sum_prev ) ; } return 0 ; } int recurse ( int a [ 100 ] [ 100 ] , int n , int sum , int i , int j , int sum_prev ) { sum += a [ i ] [ j ] ; if ( i == n - 1 ) { push ( sum ) ; } if ( i == n - 1 && j == n - 1 ) { int z = 0 ; int m ; while ( ! is_empty ( ) ) { m = pop ( ) ; if ( m > z ) { z = m ; } } printf ( "%d\n" , z ) ; return ; } if ( i < n ) { recurse ( a , n , sum , i + 1 , j , sum_prev ) ; recurse ( a , n , sum , i + 1 , j + 1 , sum_prev ) ; } } int push ( int item ) { if ( is_full ( ) ) { return ; } else { top = top + 1 ; stack [ top ] = item ; return stack [ top ] ; } } int is_full ( ) { if ( top == max ) { return 1 ; } else { return 0 ; } } int is_empty ( ) { if ( top == - 1 ) { return 1 ; } else { return 0 ; } } int pop ( ) { int x ; if ( is_empty ( ) ) { return ; } else { x = stack [ top ] ; top = top - 1 ; return x ; } }
struct tree { int value ; int row ; int col ; long long sum ; struct tree * lchild ; struct tree * rchild ; } ; struct tree * queue [ MAX ] ; int front = - 1 ; int rear = - 1 ; int count = 0 ; void enqueue ( struct tree * ) ; struct tree * dequeue ( ) ; main ( ) { int test , i , row , j , k ; long long max ; struct tree * node , * root = NULL , * temp ; scanf ( "%d" , & test ) ; for ( i = 0 ; i < test ; i ++ ) { scanf ( "%d" , & row ) ; int a [ row ] [ row ] ; for ( j = 0 ; j < row ; j ++ ) for ( k = 0 ; k < row ; k ++ ) a [ j ] [ k ] = 0 ; for ( j = 0 ; j < row ; j ++ ) for ( k = 0 ; k < row ; k ++ ) { if ( k > j ) break ; scanf ( "%d" , & a [ j ] [ k ] ) ; } node = ( struct tree * ) malloc ( sizeof ( struct tree ) ) ; node -> value = a [ 0 ] [ 0 ] ; node -> row = 0 ; node -> col = 0 ; node -> sum = a [ 0 ] [ 0 ] ; node -> lchild = NULL ; node -> rchild = NULL ; root = node ; max = node -> value ; while ( node -> row < row - 1 ) { printf ( "at start count = %d\n" , count ) ; temp = ( struct tree * ) malloc ( sizeof ( struct tree ) ) ; node -> lchild = temp ; temp -> value = a [ node -> row + 1 ] [ node -> col ] ; temp -> row = node -> row + 1 ; temp -> col = node -> col ; temp -> sum = temp -> value + node -> sum ; if ( temp -> sum > max ) max = temp -> sum ; enqueue ( temp ) ; temp = ( struct tree * ) malloc ( sizeof ( struct tree ) ) ; node -> rchild = temp ; temp -> value = a [ node -> row + 1 ] [ node -> col + 1 ] ; temp -> row = node -> row + 1 ; temp -> col = node -> col + 1 ; temp -> sum = temp -> value + node -> sum ; if ( temp -> sum > max ) max = temp -> sum ; enqueue ( temp ) ; node = dequeue ( ) ; } printf ( "%lld\n" , max ) ; } return 0 ; } void enqueue ( struct tree * ptr ) { if ( ( front - rear ) == MAX - 1 || rear - front == 1 ) { return ; } else if ( front == - 1 && rear == - 1 ) { front = 0 ; rear = 0 ; queue [ front ] = ptr ; } else if ( front == MAX - 1 ) { front = 0 ; queue [ front ] = ptr ; } else { front ++ ; queue [ front ] = ptr ; } } struct tree * dequeue ( ) { struct tree * deque ; if ( rear == - 1 && front == - 1 ) { return NULL ; } else if ( rear == MAX - 1 ) { deque = queue [ rear ] ; rear = 0 ; return deque ; } else if ( rear == front ) { deque = queue [ rear ] ; rear = - 1 ; front = - 1 ; return deque ; } else { deque = queue [ rear ] ; rear ++ ; return deque ; } }